#!/bin/bash

# =============================================================================
# Git Pre-commit Hook for Risk-Map Validation
# =============================================================================
# This hook validates:
# - component edge consistency
# - control-risk cross-reference integrity
# - YAML schema compliance
# 
# Manual Installation: 
#   Save as .git/hooks/pre-commit and chmod +x .git/hooks/pre-commit
#
# Behavior:
#   - Validates only staged files by default
#   - If... 
#        - riskmap.schema.json changes, validates YAML schema compliance for 
#          all files
#        - components.yaml changes, generates a new component graph at
#          ./risk-map/docs/risk-map-graph.md and adds it to the staged files
#        - components.yaml or controls.yaml changes, generates a new control graph at
#          ./risk-map/docs/controls-graph.md and adds it to the staged files
#   - Use --force/-f to run all validations against all files regardless of
#     staging status. NOTE: --force will not generate new graphs
#   - See ./git/hooks/validate_component_edges.py for manual graph generation
#        
# =============================================================================

# =============================================================================
# Configuration and Constants
# =============================================================================

# Base URI for schema resolution - must be absolute file:// path
BASE_URI="file://$(pwd)/risk-map/schemas/"

# Directory paths for YAML files and schemas
YAML_BASE_DIR="risk-map/yaml"
SCHEMA_BASE_DIR="risk-map/schemas"

# Suffix for schema files
SCHEMA_SUFFIX=".schema.json"

# List of YAML|schema files to validate without extensions
SOURCE_FILES=("controls" "components" "personas" "risks" "self-assessment")

# =============================================================================
# Global Variables and Flags
# =============================================================================

# Flag to force validation of all files (0=false, 1=true)
FORCE_VALIDATE=0

# Arguments to pass to edge/reference validators ("" or "--force")
EDGE_ARGS=""

# Variable to track if any validation failed (0=all passed, 1=some failed)
VALIDATION_FAILED=0

# =============================================================================
# Dependency Checks
# =============================================================================

# Ensure check-jsonschema is installed before proceeding
if ! command -v check-jsonschema &> /dev/null; then
    echo "Error: check-jsonschema is not installed. Install with: pip install check-jsonschema"
    exit 1
fi

# =============================================================================
# Core Schema Validation Functions
# =============================================================================

# Validates a single YAML file against its corresponding JSON schema
# Args:
#   $1 - target: filename without extension (e.g., "controls")
#   $2 - error_type: optional custom error message
check_schema() {
    local target="$1"
    local error_type="$2"

    # Construct file paths
    local schema_file="${SCHEMA_BASE_DIR}/${target}${SCHEMA_SUFFIX}"
    local yaml_file="${YAML_BASE_DIR}/${target}.yaml"

    echo "Validating $yaml_file against $schema_file..."
    
    # Run validation and capture exit code
    if ! check-jsonschema --base-uri "$BASE_URI" --schemafile "${schema_file}" "${yaml_file}" > /dev/null ; then
        # Handle validation failure
        if [[ -n "$error_type" ]]; then
            echo "$error_type"
            return 1  # Return error but don't exit (for batch validation)
        else 
            echo "‚ùå Schema validation failed for ${target}.yaml"
            return 1   # Return error but don't exit 
        fi
    fi
    
    echo "‚úÖ Schema validation passed for ${target}.yaml"
}

# Validates a YAML file only if it or its schema is staged for commit
# Args:
#   $1 - target: filename without extension
# Returns:
#   0 if validation passed or file not staged, 1 if validation failed
validate_if_staged() {
    local target=$1
    local yaml_file="${YAML_BASE_DIR}/${target}.yaml"
    local schema_file="${SCHEMA_BASE_DIR}/${target}${SCHEMA_SUFFIX}"

    # Check if either the YAML file or its schema is staged
    if git diff --cached --name-only | grep -q "${yaml_file}$\|${schema_file}$"; then
        check_schema "$target"

        return $?  # Return error if validation failed
    fi

    return 0  # No validation needed, file not staged   
}

# Validates all YAML files (used when riskmap.schema.json changes)
# This is necessary because riskmap.schema.json affects all YAML validations
# Returns:
#   0 if validation passed or file not staged, 1 if validation failed
validate_all_yaml() {
    echo "riskmap.schema.json changed - validating all YAML files..."
    local failed=0
    echo ${SOURCE_FILES[@]} 

    # Validate each existing YAML file
    for input_file in "${SOURCE_FILES[@]}"; do
        if [[ -f "${YAML_BASE_DIR}/${input_file}.yaml" ]]; then
            # Use custom error message for batch validation
            check_schema "$input_file" "‚ùå Schema validation for ${input_file}.yaml failed due to riskmap.schema.json changes"
            if [[ $? -ne 0 ]]; then
                failed=1  # Mark as failed but continue checking other files
            fi
        fi
    done

    # Exit with error if any validation failed
    if [[ $failed -ne 0 ]]; then
        return 1
    fi 

    echo "‚úÖ All YAML files still valid after riskmap schema changes"
}

# =============================================================================
# Command Line Argument Parsing
# =============================================================================

# Parse command-line arguments for help and force options
case $1 in
    --help|-h)
        echo "Usage: pre-commit hook for validating risk-map tooling"
        echo "Validates only staged files unless riskmap.schema.json is modified or -f|--force , in which case all YAML files are validated."
        echo "----"
        echo "Options:"
        echo "  --help|-h       Show this help message and exit"
        echo "  --force|-f      Force validation of all risk-map files regardless of staging status"
        echo "----"
        echo "Validations performed:"
        echo "  - YAML schema validation"
        echo "  - Prettier formatting (risk-map/yaml/ files only)"
        echo "  - Ruff linting (Python files only)"
        echo "  - Component edge validation"
        echo "  - Control-to-risk reference validation"
        echo ""
        echo "Graph generation:"
        echo "  - When components.yaml is staged, automatically generates ./risk-map/docs/risk-map-graph.md"
        echo "  - When components.yaml or controls.yaml is staged, automatically generates ./risk-map/docs/controls-graph.md"
        echo "  - Generated graphs are added to staged files for inclusion in commit"
        echo "  - Graph generation is skipped in --force mode"
        echo "  - Use .git/hooks/validate_component_edges.py for manual graph generation"
        exit 0
        ;;
    --force|-f)
        echo "Force validating all risk-map files..."
        FORCE_VALIDATE=1
        EDGE_ARGS="--force"  # Pass force flag to sub-validators
esac

# =============================================================================
# Main Schema Validation Logic
# =============================================================================

echo "Running YAML schema validation..."

# If riskmap.schema.json is being modified, validate all YAML files
# This is necessary because this master schema affects all other validations
if git diff --cached --name-only | grep -q "schemas/riskmap\.schema\.json$" ; then
    validate_all_yaml
    if [[ $? -ne 0 ]]; then
        VALIDATION_FAILED=1  # Mark as failed but continue checking other files
    fi
fi

# Validate individual YAML files based on what's staged or force flag
failed=0
for each in "${SOURCE_FILES[@]}"; do
    if [[ $FORCE_VALIDATE -eq 1 ]]; then
        # Force mode: validate all files regardless of staging status
        check_schema "$each"
        failed=$?
    else
        # Normal mode: only validate if file is staged
        validate_if_staged "$each"
        failed=$?
    fi
    if [[ $failed -ne 0 ]]; then
        VALIDATION_FAILED=1  # Mark as failed but continue checking other files
    fi
done



# =============================================================================
# Prettier Formatting for YAML Files
# =============================================================================

# Formats YAML files in risk-map/yaml directory using prettier
# Args: none (uses global FORCE_VALIDATE and EDGE_ARGS flags)
# Behavior:
#   - Normal mode: formats only staged YAML files in risk-map/yaml/
#   - Force mode: formats all YAML files in risk-map/yaml/
format_yaml_files() {
    echo "üé® Running prettier formatting on YAML files..."
    
    local files_to_format=()
    local formatting_failed=0
    
    if [[ $FORCE_VALIDATE -eq 1 ]]; then
        # Force mode: format all YAML files in risk-map/yaml/
        echo "   Force mode: formatting all YAML files in risk-map/yaml/"
        for file in risk-map/yaml/*.yaml; do
            if [[ -f "$file" ]]; then
                files_to_format+=("$file")
            fi
        done
    else
        # Normal mode: format only staged YAML files in risk-map/yaml/
        echo "   Normal mode: formatting staged YAML files in risk-map/yaml/"
        while IFS= read -r -d '' file; do
            # Only include files that are in risk-map/yaml/ directory
            if [[ "$file" == risk-map/yaml/*.yaml ]]; then
                files_to_format+=("$file")
            fi
        done < <(git diff --cached --name-only -z | grep -z '\.ya\?ml$')
    fi
    
    # Format files if any were found
    if [[ ${#files_to_format[@]} -gt 0 ]]; then
        echo "   Formatting ${#files_to_format[@]} YAML file(s)..."
        
        for file in "${files_to_format[@]}"; do
            echo "   Formatting $file..."
            if ! npx prettier --write "$file"; then
                echo "   ‚ùå Prettier formatting failed for $file"
                formatting_failed=1
            else
                echo "   ‚úÖ Formatted $file"
                # Add formatted file back to staging area (only in normal mode)
                if [[ $FORCE_VALIDATE -eq 0 ]] && ! git add "$file"; then
                    echo "   ‚ö†Ô∏è  Warning: Could not stage formatted file $file"
                fi
            fi
        done
        
        if [[ $formatting_failed -eq 0 ]]; then
            echo "   ‚úÖ All YAML files formatted successfully"
        fi
    else
        echo "   No YAML files in risk-map/yaml/ to format"
    fi
    
    return $formatting_failed
}

# Run prettier formatting
format_yaml_files
if [[ $? -ne 0 ]]; then
    VALIDATION_FAILED=1
fi

# =============================================================================
# Ruff Linting for Python Files
# =============================================================================

# Runs ruff linting on Python files
# Args: none (uses global FORCE_VALIDATE flag)
# Behavior:
#   - Normal mode: lints only staged Python files
#   - Force mode: lints all Python files in the repository
run_ruff_check() {
    echo "üîç Running ruff linting on Python files..."
    
    local ruff_failed=0
    local files_to_check=()
    
    if [[ $FORCE_VALIDATE -eq 1 ]]; then
        # Force mode: check all Python files
        echo "   Force mode: linting all Python files"
        if ! ruff check .; then
            echo "   ‚ùå Ruff linting failed"
            ruff_failed=1
        else
            echo "   ‚úÖ All Python files passed ruff linting"
        fi
    else
        # Normal mode: check only staged Python files
        echo "   Normal mode: linting staged Python files"
        
        # Get staged Python files
        while IFS= read -r -d '' file; do
            if [[ -f "$file" ]]; then
                files_to_check+=("$file")
            fi
        done < <(git diff --cached --name-only -z | grep -z '\.py$')
        
        if [[ ${#files_to_check[@]} -gt 0 ]]; then
            echo "   Checking ${#files_to_check[@]} Python file(s)..."
            if ! ruff check "${files_to_check[@]}"; then
                echo "   ‚ùå Ruff linting failed for staged files"
                ruff_failed=1
            else
                echo "   ‚úÖ All staged Python files passed ruff linting"
            fi
        else
            echo "   No staged Python files to check"
        fi
    fi
    
    return $ruff_failed
}

# Run ruff check
run_ruff_check
if [[ $? -ne 0 ]]; then
    VALIDATION_FAILED=1
fi

echo  # Add blank line for readability

# =============================================================================
# Component Edge Validation
# =============================================================================
echo "üîó Running component edge validation..."

# Path to the component edge validation script
EDGE_VALIDATOR=".git/hooks/validate_component_edges.py"

# Check if validator exists before attempting to run it
if [[ ! -f "$EDGE_VALIDATOR" ]]; then
    echo "   Warning: Component edge validator not found at $EDGE_VALIDATOR"
    echo "   Skipping edge validation..."
else
    # Run the component edge validation with appropriate args based on passed flags
    if ! python3 "$EDGE_VALIDATOR" $EDGE_ARGS; then
        VALIDATION_FAILED=1 # Mark as failed if edge validation fails
    fi
fi

# =============================================================================
# Component Graph Generation (when components.yaml changes)
# =============================================================================

# Only generate component graph in normal mode (not --force) when components.yaml is staged
if [[ $FORCE_VALIDATE -eq 0 ]] && git diff --cached --name-only | grep -q "risk-map/yaml/components\.yaml$"; then
    echo "üìä Components.yaml changed - generating component relationship graph..."
    
    # Ensure docs directory exists
    mkdir -p risk-map/docs
    
    # Generate the graph using the validator script
    if python3 "$EDGE_VALIDATOR" --to-graph "./risk-map/docs/risk-map-graph.md" --quiet; then
        echo "   ‚úÖ Graph generated at ./risk-map/docs/risk-map-graph.md"
        
        # Add the generated graph to staging area
        if git add "./risk-map/docs/risk-map-graph.md"; then
            echo "   ‚úÖ Risk Map Graph added to staged files"
        else
            echo "   ‚ö†Ô∏è  Warning: Could not stage generated graph"
        fi
    else
        echo "   ‚ùå Risk Map Graph generation failed"
        VALIDATION_FAILED=1
    fi
fi

echo  # Add blank line for readability

# =============================================================================
# Control-to-Risk Reference Validation
# =============================================================================
echo "üîó Running control-to-risk reference validation..."

# Path to the control-risk reference validation script
REF_VALIDATOR=".git/hooks/validate_control_risk_references.py"

# Check if validator exists before attempting to run it
if [[ ! -f "$REF_VALIDATOR" ]]; then
    echo "   Warning: Control-to-risk reference validator not found at $REF_VALIDATOR"
    echo "   Skipping reference validation..."
else
    # Run the control-risk reference validation
    # Uses same EDGE_ARGS since both validators support --force flag
    if ! python3 "$REF_VALIDATOR" $EDGE_ARGS; then
        VALIDATION_FAILED=1 # Mark as failed if reference validation fails
    fi
fi

echo  # Add blank line for readability

# =============================================================================
# Control Graph Generation (when components.yaml or controls.yaml changes)
# =============================================================================

# Only generate control graph in normal mode (not --force) when components.yaml or controls.yaml is staged
# Control graph depends on both files, so regenerate if either changes
if [[ $FORCE_VALIDATE -eq 0 ]] && git diff --cached --name-only | grep -q "risk-map/yaml/\(components\|controls\)\.yaml$"; then
    echo "üìä Components or controls changed - generating control-to-component graph..."

    # Ensure docs directory exists
    mkdir -p risk-map/docs

    # Generate the control graph using the validator script
    if python3 "$EDGE_VALIDATOR" --to-controls-graph "./risk-map/docs/controls-graph.md" --quiet; then
        echo "   ‚úÖ Control graph generated at ./risk-map/docs/controls-graph.md"

        # Add the generated graph to staging area
        if git add "./risk-map/docs/controls-graph.md"; then
            echo "   ‚úÖ Controls Graph added to staged files"
        else
            echo "   ‚ö†Ô∏è  Warning: Could not stage generated control graph"
        fi
    else
        echo "   ‚ùå Control Graph generation failed"
        VALIDATION_FAILED=1
    fi
fi

echo  # Add blank line for readability

# Exit with error if any validation failed
if [[ $VALIDATION_FAILED -ne 0 ]]; then
    exit 1
fi 

# =============================================================================
# Success Summary
# =============================================================================
echo "üéâ All pre-commit validations passed!"
echo "   ‚úÖ YAML schema validation"
echo "   ‚úÖ Prettier formatting"
echo "   ‚úÖ Ruff linting"
echo "   ‚úÖ Component edge validation"
echo "   ‚úÖ Control-to-risk reference validation"

# Check if component graph was generated and add to summary
if [[ $FORCE_VALIDATE -eq 0 ]] && git diff --cached --name-only | grep -q "risk-map/yaml/components\.yaml$"; then
    echo "   üìä Component Graph generated and staged"
fi

# Check if control graph was generated and add to summary
if [[ $FORCE_VALIDATE -eq 0 ]] && git diff --cached --name-only | grep -q "risk-map/yaml/\(components\|controls\)\.yaml$"; then
    echo "   üìä Control Graph generated and staged"
fi

echo "Ready to commit! üöÄ"